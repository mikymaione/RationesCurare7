<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="errAmbiguousMatch" xml:space="preserve">
    <value>Ambiguous match between</value>
  </data>
  <data name="errArgumentExist" xml:space="preserve">
    <value>Argument "{0}" already exist in the list.</value>
  </data>
  <data name="errConstantExist" xml:space="preserve">
    <value>Constant "{0}" already exist in the list.</value>
  </data>
  <data name="errConstantNotExist" xml:space="preserve">
    <value>Constant "{0}" does not exist in collection.</value>
  </data>
  <data name="errCultureExtract" xml:space="preserve">
    <value>Can't extract culture-specified separators chars.</value>
  </data>
  <data name="errDelegateInvCount" xml:space="preserve">
    <value>Delegate's invocation list count should be equal one.</value>
  </data>
  <data name="errDelegateWithTarget" xml:space="preserve">
    <value>Delegates with target is not supported (maybe because of closure).</value>
  </data>
  <data name="errDisbalanceClose" xml:space="preserve">
    <value>Brace disbalance (not closed).</value>
  </data>
  <data name="errDisbalanceOpen" xml:space="preserve">
    <value>Brace disbalance (not opened).</value>
  </data>
  <data name="errEndlessLoop" xml:space="preserve">
    <value>Wrong range step: endless loop.</value>
  </data>
  <data name="errExistOverload" xml:space="preserve">
    <value>There is overload(s) with {0} argument(s).</value>
  </data>
  <data name="errFunctionNoBrace" xml:space="preserve">
    <value>Opening brace should be placed after function name</value>
  </data>
  <data name="errFunctionNotExist" xml:space="preserve">
    <value>Function "{0}" does not exist in the collection.</value>
  </data>
  <data name="errGenericRange" xml:space="preserve">
    <value>Wrong range: type '{0}' is not supported as type parameter of ValueRange&lt;T&gt; structure.</value>
  </data>
  <data name="errIdentifierEmpty" xml:space="preserve">
    <value>Empty or null identifier name.</value>
  </data>
  <data name="errIdentifierFromLambda" xml:space="preserve">
    <value>Maybe trying to import lambda without specifying the name?</value>
  </data>
  <data name="errIdentifierStartsWith" xml:space="preserve">
    <value>Incorrect identifier name: "{0}". Name should begin with a letter or underscore.</value>
  </data>
  <data name="errIdentifierSymbol" xml:space="preserve">
    <value>Incorrect symbol '{0}' in identifier name "{1}". Only letters, digits and underscore symbol are allowed.</value>
  </data>
  <data name="errIncorrectConstr" xml:space="preserve">
    <value>Incorrect construction</value>
  </data>
  <data name="errInvalidSeparator" xml:space="preserve">
    <value>Invalid (separator) usage.</value>
  </data>
  <data name="errMethodBadParam" xml:space="preserve">
    <value>parameter #{0} of '{1}' type. All parameters should be of '{2}' type.</value>
  </data>
  <data name="errMethodBadReturn" xml:space="preserve">
    <value>returns value of '{0}' type. Function should return '{1}' type.</value>
  </data>
  <data name="errMethodImportFailed" xml:space="preserve">
    <value>Import failed: method</value>
  </data>
  <data name="errMethodNonPublic" xml:space="preserve">
    <value>Method '{0}' is not public.</value>
  </data>
  <data name="errMethodNotFounded" xml:space="preserve">
    <value>Method "{0}" cannot be founded (non public / not static?).</value>
  </data>
  <data name="errMethodNotInstance" xml:space="preserve">
    <value>must be instance method.</value>
  </data>
  <data name="errMethodNotRuntimeMethod" xml:space="preserve">
    <value>should be standard runtime method (DynamicMethod is not supported).</value>
  </data>
  <data name="errMethodNotStatic" xml:space="preserve">
    <value>must be static method.</value>
  </data>
  <data name="errNeutralCulture" xml:space="preserve">
    <value>Culture '{0}' is neutral culture. It cannot be used for parse and formatting .</value>
  </data>
  <data name="errNotSupported" xml:space="preserve">
    <value>Operation ({0}) isn't supported for the '{1}' type.</value>
  </data>
  <data name="errNumberFormat" xml:space="preserve">
    <value>Incorrect number format:</value>
  </data>
  <data name="errNumberOverflow" xml:space="preserve">
    <value>Literal value overflow:</value>
  </data>
  <data name="errOverloadImpossible" xml:space="preserve">
    <value>Function with same parameters ({0}) is already in the list (overload impossible).</value>
  </data>
  <data name="errParseLiteralHint" xml:space="preserve">
    <value>If this is a part of literal, note that '{0}' doesn't support parse of literals.</value>
  </data>
  <data name="errRangeNotFinite" xml:space="preserve">
    <value>Wrong range: Begin, End or Step is not finite value.</value>
  </data>
  <data name="errRangeZeroInit" xml:space="preserve">
    <value>Wrong range: non initialized (do not use parameterless constructor or default(ValueRange&lt;T&gt;)).</value>
  </data>
  <data name="errTabulatorWrongArgs" xml:space="preserve">
    <value>Tabulator object can be created only for the expressions with one or more arguments.</value>
  </data>
  <data name="errTooLongRange" xml:space="preserve">
    <value>Wrong range: iterations count doesn't fit in integer values range.</value>
  </data>
  <data name="errTypeNonPublic" xml:space="preserve">
    <value>Type '{0}' is not visible for ILCalc.</value>
  </data>
  <data name="errUnresolvedIdentifier" xml:space="preserve">
    <value>Unresolved identifier:</value>
  </data>
  <data name="errUnresolvedSymbol" xml:space="preserve">
    <value>Unresolved symbol:</value>
  </data>
  <data name="errWrongArgsCount" xml:space="preserve">
    <value>Wrong arguments count: {0}. You should specify {1} argument(s) for the Evaluate() method.</value>
  </data>
  <data name="errWrongOverload" xml:space="preserve">
    <value>isn't got overload with {0} argument(s).</value>
  </data>
  <data name="errWrongRangesCount" xml:space="preserve">
    <value>Wrong ranges count: {0}. You should specify {1} ranges(s) for the Tabulate() method.</value>
  </data>
  <data name="errWrongStepSign" xml:space="preserve">
    <value>Wrong range step: invalid step sign.</value>
  </data>
  <data name="errWrongTargetType" xml:space="preserve">
    <value>Wrong target object type: {0} (not assignable to {1}).</value>
  </data>
  <data name="sAnd" xml:space="preserve">
    <value>and</value>
  </data>
  <data name="sArgument" xml:space="preserve">
    <value>Argument</value>
  </data>
  <data name="sConstant" xml:space="preserve">
    <value>Constant</value>
  </data>
  <data name="sFunction" xml:space="preserve">
    <value>Function</value>
  </data>
</root>